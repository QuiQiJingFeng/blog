---
layout: post
title:  "Spine 中的结构、概念和原理"
image: ''
date:   2025-05-22 11:43:33
tags:
- Spine
description: ''
categories: 
- Spine
---
Skeleton
├── Bones  
│   └── 形成树状结构，控制层级变换  
├── Slots  
│   └── 附加到骨骼，控制显示内容  (也有不附加到骨骼的方法,比如Mesh指定骨骼)
│       └── Attachment (Region / Mesh / etc)  
├── Skins  
│   └── 每个 skin 提供不同的附件组合（换装）  
├── Animations  
│   └── 每个动画包含多个 Timeline（对骨骼/插槽/事件的关键帧）  
├── Constraints  
│   ├── IKConstraint  
│   ├── TransformConstraint  
│   └── PathConstraint  
├── Events  
└── Draw Order  

#### 骨骼数据
```c
typedef enum {
	SP_TRANSFORMMODE_NORMAL,                        //完全继承父骨骼的缩放、旋转等变换
	SP_TRANSFORMMODE_ONLYTRANSLATION,               //只继承父骨骼的位移
	SP_TRANSFORMMODE_NOROTATIONORREFLECTION,        //不继承旋转和翻转
	SP_TRANSFORMMODE_NOSCALE,                       //不继承缩放
	SP_TRANSFORMMODE_NOSCALEORREFLECTION            //不继承缩放与翻转
} spTransformMode;

typedef struct spBoneData spBoneData;
struct spBoneData {
	const int index;
	const char* const name;
	spBoneData* const parent;
	float length;//骨骼长度
	float x, y, rotation, scaleX, scaleY, shearX, shearY; //shearX/shearY 斜切角

	spTransformMode transformMode;  //控制父骨骼的变换对当前骨骼的影响方式
}
```
#### 附件类型
```c
typedef enum {
	SP_ATTACHMENT_REGION,                       //区域附件 最常用的附件类型，表示一张矩形图片（通常是 PNG 图中的一块区域）
	SP_ATTACHMENT_BOUNDING_BOX,                 //包围盒附件   一个由若干点定义的多边形，用于碰撞检测或交互区域
	SP_ATTACHMENT_MESH,                         //网格附件     带多个顶点和三角形索引的图像，可实现任意变形  布料、面部动画、复杂动作
	SP_ATTACHMENT_LINKED_MESH,                  //链接网格附件  引用另一个 MeshAttachment，共享顶点和图像 图像可以切换，顶点数据不允许更改
	SP_ATTACHMENT_PATH,                         //路径附件     一组控制点组成的贝塞尔曲线路径
	SP_ATTACHMENT_POINT,                        //点附件       一个位置点，带有旋转信息  用于挂载武器、粒子、音效等
	SP_ATTACHMENT_CLIPPING                      //剪切附件     定义一个区域用于裁剪其他附件的显示区域
} spAttachmentType;
```

#### 约束类型
#### 1. IK Constraint（反向运动学）
* 控制目标： 骨骼链（通常是2个骨骼）

* 目标对象： 目标骨骼的位置

* 典型用途： 控制手臂、腿、尾巴末端的定位

* 特点： 自动解算中间骨骼的角度，让末端对准目标

* ✅ 例子：你把「手」移动，系统会自动弯曲「前臂」和「上臂」来让手跟随。（多个骨骼一个目标点，是因为多个骨骼间需要满足一定的关系，因为骨骼是有长度的，所以一些旋转方案无法满足整体需要）
```
PS: IK约束的话对于一些动作可能无法处理，比如手腕在一个地方时，前臂和上臂的位置就有两种组合，
类似三个点，在线段长度固定的情况下,中间的点还有上下可选多于3个点的话就更多了,
对于三个点的情况还可以通过bendDirection控制上下方向,
对于多个的情况,建议转换成三个点的模式处理,或者单纯由关键帧驱动。
```
```c
constraint->bendDirection = 1; // 肘部向上
constraint->bendDirection = -1; // 肘部向下
```

##### Spine 的 IK 系统设计为“快速满足大多数动画需求”，而不是物理级别的完整 IK 解算。所以它不允许IK叠加：

* 只支持两骨链；

* 不支持约束间递归依赖；

* 每帧是静态执行（无动力学），按顺序解算一次。

#### 2. Path Constraint（路径约束）
* 控制目标： 一个路径（Path Attachment）所在的 Slot

* 目标对象： 路径（Bezier 曲线）

* 典型用途： 蛇、尾巴、头发、链条沿路径排列或运动

* 特点： 多个骨骼沿路径排列、移动、旋转

* ✅ 例子：鱼的身体像蛇一样扭动，你只需要动画路径，骨骼自动贴合。
```
PS:路径约束只对约束的骨骼起作用,最好做原地动画，如果出现位置移动的话，容易导致跟其他骨骼位置分离,
比如脚离开了，身体留在原地了。  
或者整个角色骨架挂载到一个“路径控制用的骨骼”上，这个骨骼沿路径平滑移动,但是这种要求子骨骼继承父骨骼的transform的移动和旋转的属性
```

#### 3. Transform Constraint（变换约束）
* 控制目标： 一个目标骨骼

* 目标对象： 被约束的骨骼（一个或多个）

* 典型用途： 子骨骼跟随主骨骼的位置、旋转、缩放变化

* 特点： 可部分或全部同步变换；支持 mix 强度

* ✅ 例子：让一个饰品随着头部骨骼的旋转而轻微移动（旋转 mix 设为 0.5）

```
没有约束的情况下,子骨骼默认也会跟随父骨骼移动，旋转和缩放,子骨骼也可以通过设置只跟随某一些属性
```

#### 路径附件和路径约束之间的关系
__“路径约束控制骨骼沿着路径附件分布或运动，路径附件定义路径形状，路径约束决定骨骼怎么使用这条路径。”__

#### 独立于骨骼的插槽，通过网格附件指定多个骨骼从而达到跟随的目的
```
root
├── bone1（旗杆顶部）
├── bone2（旗帜中段）
├── bone3（旗帜底部）
└── slot（绑定旗帜图片，挂在 root 上）

旗帜 mesh 顶点绑定：
  顶部点 → bone1
  中部点 → bone1 + bone2
  底部点 → bone2 + bone3
```
优点|说明
:-|:-
✅ 插槽不参与运动	|插槽不用再自己移动，靠骨骼变形就能实现复杂动作
✅ 多骨骼混合控制	|可以实现柔性物体效果：布料、头发、尾巴、舌头等
✅ 减少层级耦合	|插槽不用挂在哪个特定骨骼下，自由绑定根骨骼
✅ 精确控制变形	|每个顶点可以精细设置影响骨骼和比例

```
比如将Mesh的某个骨骼的权重设置为100%,那么跟将插槽绑定到骨骼下面效果其实是一样的,
而且找起来还方便，不像挂到骨骼下面还得一层一层的去找。
```

#### 扁平结构的骨骼结构
```
[原始结构]
root
└── 上臂
    └── 前臂
        └── 手

[拆成平级]
root
├── 上臂
├── 前臂
├── 手
```
##### 扁平结构的好处和坏处

| 结构类型           | 优点                                       | 缺点                                   |
| -------------- | ---------------------------------------- | ------------------------------------ |
| **树状结构（传统）**   | ✅ 结构清晰<br>✅ 父子自动跟随<br>✅ 少量约束就能驱动         | ❌ 不够灵活<br>❌ 局部控制难以解耦<br>❌ 多种动画混合困难   |
| **扁平结构（约束驱动）** | ✅ 极高的灵活性<br>✅ 各部分独立控制<br>✅ 更容易动画复用 / 模块化 | ❌ 驱动逻辑复杂<br>❌ 需要更多约束<br>❌ 调试困难、学习曲线陡 |


