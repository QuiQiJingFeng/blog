---
layout: post
title:  "CC_ENABLE_CACHE_TEXTURE_DATA 宏问题"
image: ''
date:   2025-05-06 16:47:24
tags:
- Cocos
description: ''
categories: 
- Cocos
---
```
之前的时候可能是为了解决重后台返回重建资源的时候黑屏一段时间的问题
然后将CC_ENABLE_CACHE_TEXTURE_DATA设置为了0
```
```
这样就会出现一个问题,那就是长时间在后台GL资源被系统释放，或者某种操作触发系统回收GL资源的情况下,重新切回前台就会出现各种GL错误导致的崩溃。
```
所以现在遇到一个两种处理方式都有各自问题的情况，  
#### 不缓存重建资源的话有可能GL资源被释放导致返回前台崩溃(比如Texture2D创建出现错误)
#### 缓存资源的话,需要处理lua中shader的重建问题以及重建过程中会黑屏一段时间的问题。


```c++
void Java_org_cocos2dx_lib_Cocos2dxRenderer_nativeInit(JNIEnv*  env, jobject thiz, jint w, jint h)
{
    auto director = cocos2d::Director::getInstance();
    auto glview = director->getOpenGLView();
    if (!glview)
    {
        glview = cocos2d::GLViewImpl::create("Android app");
        glview->setFrameSize(w, h);
        director->setOpenGLView(glview);

        //cocos_android_app_init(env, thiz);

        cocos2d::Application::getInstance()->run();  
    }
    else
    {
        cocos2d::GL::invalidateStateCache();
        cocos2d::GLProgramCache::getInstance()->reloadDefaultGLPrograms();
        cocos2d::DrawPrimitives::init();
        cocos2d::VolatileTextureMgr::reloadAllTextures();

        cocos2d::EventCustom recreatedEvent(EVENT_RENDERER_RECREATED);
        director->getEventDispatcher()->dispatchEvent(&recreatedEvent);
        director->setGLDefaultValues();
    }
}
```

```
可以看到shader的重建是通过reloadDefaultGLPrograms重建的,也就是不支持lua中的自定义shader的重建,除非自己在lua中处理。
如果lua中自定义shader很多就挺麻烦的，最好有一个统一的shader管理器来维持重建的处理
```

#### 黑屏问题是15年的时候了,现在的话可能会好一点,所以采用重建shader的处理会更好一点
```c++
void GLProgramCache::reloadDefaultGLPrograms()
{
    // reset all programs and reload them
    
    // Position Texture Color shader
    GLProgram *p = getGLProgram(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR);    
    p->reset();
    loadDefaultGLProgram(p, kShaderType_PositionTextureColor);
    //...
}
```
```
shader重建的代码是找到原始的指针然后重新编译shader,以及绑定属性
```
#### 所以如果要在lua中处理相同问题的话,至少需要Java_org_cocos2dx_lib_Cocos2dxRenderer_nativeInit的时候  
#### 通知lua重建shader,为了获取当前指针可能还需要修改lua绑定之类的

#### 复现操作可以用开发者模式中的离开销毁Activity处理